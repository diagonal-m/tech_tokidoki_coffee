---
title: 個人的アプリケーションアーキテクチャ入門
date: '2024-01-13'
tags: ['design', 'architecture']
draft: false
summary: '3層アーキテクチャ、N層アーキテクチャ、ヘキサゴナル・オニオン・クリーンアーキテクチャ'
---

## 目次

<TOCInline toc={props.toc} exclude="目次" toHeading={3} />

## アプリケーションアーキテクチャとは

- アーキテクチャは元々建築業界で使われていた言葉で、日本語にすると「建築様式」などと訳される。
- ソフトウェア開発では「構造」や「構成」という意味で使われるものの、明確な定義は存在せず、文脈によって解釈される。
  - この記事では「アプリケーションアーキテクチャ」は「開発するアプリケーションの構造」として扱う

![application_arichitecture_target](/static/images/architecture/application_architecture_target.png)

### アプリケーションアーキテクチャ設計の目的

アプリケーションアーキテクチャを設計する目的としては、大きく以下の 3 つが挙げられる。

- アプリケーション全体の整合性の確保
- 設計品質の向上
- 拡張性・保守性の向上

### アプリケーションアーキテクチャと開発工程

- ウォーターフォール開発の場合は、一般的には以下のような流れで開発が進む
  1. 要件定義
  2. 基本設計
  3. 詳細設計
  4. プログミング
  5. テスト
- アプリケーションアーキテクチャ設計は基本設計フェーズ内の比較的早い段階で完了させる

## 3 層アーキテクチャ

> アプリケーションの内部を**プレゼンテーション層**(または**ユーザーインタフェース層**)、**アプリケーション層**(または**ビジネスロジック層**)、**データアクセス層**の 3 層に分けてアプリケーションを構成する基本的なアーキテクチャを 3 層アーキテクチャと呼ぶ。

![3層アーキテクチャ](/static/images/architecture/3層アーキテクチャ.png)

### プレゼンテーション層

> ユーザーインタフェースやクライアントサイド等アプリケーションの利用者とやり取りするのが役割。  
> 上図ではプレゼンテーション層において、外部からのリクエストを受け取り、適切なサービスとやり取りをして、レスポンスを返す

- プレゼンテーション層では以下のような処理が実装される

  - URL やアクションタイプ（GET、POST、PUT、DELETE など）の解析処理
  - リクエストに基づいて適切なサービスメソッドやアクションを呼び出す。
  - 認証や権限付与のチェック
  - リクエストの前処理や後処理

### アプリケーション層

> ビジネスロジックを処理する中間層で、システムのビジネスルールに従ったデータの処理を行う
> 上図では、dataaccess 層にある Gateway を呼び出して Record を取得し Output を返す

- アプリケーション層では以下のような処理が実装される

  - ビジネスロジックの実行
  - 複数のデータソースやコンポーネントからのでーたの統合
  - 処理結果をプレゼンテーション層に返すためのデータの準備

### データアクセス層

> データベースやファイルシステムなどのデータソースへのアクセスを提供する層  
> 上図では、テーブルと 1 対 1 対応するクラスを作成し、対象のテーブルとのやりとりを記述する、Table Data Gateway パターンを採用しており、
> テーブルと対応するデータの入れ物クラスである Record とデータストア(データベースやファイルシステム)へのアクセスを提供し、データの永続化・取得等の機能を担う

- データアクセス層では以下のような処理が実装される

  - データベース接続
  - CRUD（Create, Read, Update, Delete）操作の実行
  - SQL クエリの構築と実行

## レイヤードアーキテクチャ

### ビジネスロジックとは

> 「システムのコア」や「システムの目的の処理をするところ」

- ビジネスロジック層の処理は二種類に分けると整理しやすい
  - ユースケース(アプリケーションビジネスルール)
    - 処理の流れを実現すること
  - ドメインロジック(エンタープライズビジネスルール)
    - システム都合ではないコアなルール

### ビジネスロジックの実装方式

#### トランザクションスクリプトパターン

- 概要
  - データの入れ物と処理を分離する
  - 手続き型プログラミング
  - Service がドメインロジックとユースケースを担当
- メリット
  - 学習コストが低い
- デメリット
  - 同じロジックが Service クラス間に分散しやすく、変更に弱い
  - Service クラスが肥大化しやすい

#### ドメインモデルパターン

- 概要
  - データの入れ物に処理も持たせる
  - オブジェクト指向プログラミング
  - Model はドメインロジックを担当
  - Service はユースケースを担当
- メリット
  - 同じロジックが分散しにくく、変更に強くなりやすい
  - Service クラスが肥大化しにくい
- デメリット
  - 学習コストが高い

#### レポジトリパターン

- ドメインモデルの形式でデータを読み書きするクラスを作成するもの
- Service は Repository を使うようにして、Gateway を使わないようにすればデータベースのレコードを意識せずドメインモデルの操作に集中できる
  - Repository はデータアクセス層？ドメイン層？
    - 層の間の矢印が左から右に流れるように domain 層に置いている

![レイヤードアーキテクチャ](/static/images/architecture/レイヤードアーキテクチャ.png)

- ビジネスロジック層がアプリケーション層とドメイン層に分離
- プレゼンテーション層 → アプリケーション層 → ドメイン層 → インフラストラクチャ層と一方向に依存が流れている

  - このような構成をレイヤードアーキテクチャという
  - レイヤードアーキテクチャではデータアクセスの代わりにインフラストラクチャという単語を使うことが多い

- 上記の 3 層アーキテクチャの構成だとサービスクラスが肥大化してしまう
- ドメインという層を設けて、Model というクラスを配置した

### プレゼンテーション層

### アプリケーション層

### ドメイン層

### インフラストラクチャ層

- ## データベース・外部 API へのアクセス等、技術上の関心を解決する層

- ドメインモデルパターンでは、データの入れ物に処理も持たせている。
  - データベースのテーブルと一致したデータの入れ物クラスである Record に処理を持たせる方針も考えられる
    - Record は RDB にデータを保存することが前提
    - ドメインロジックは保存先が RDB でも他でも変わらないもの

## ヘキサゴナル・オニオン・クリーンアーキテクチャ

![ヘキサゴナル・オニオン・クリーンアーキテクチャ](/static/images/architecture/ヘキサゴナル・オニオン・クリーンアーキテクチャ.png)
