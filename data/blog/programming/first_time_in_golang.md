---
title: 動的型付け言語プログラマーによるGo言語入門
date: '2023-07-01'
tags: ['programming', 'golang']
draft: false
summary: '動的型付け言語しか実務で扱ったことのないエンジニアによるGo言語の入門記事です'
---

## 目次
<TOCInline toc={props.toc} exclude="目次" toHeading={3} />

## はじめに 
　Go言語について基本的な情報と、動的型付け言語と静的型付き言語の違いについて

### 動的型付け言語と静的型付け言語の違い
- 動的型付け言語
  - 変数の型はプログラムが実行されるときに決定される。   
    e.g.) Python, JavaScript
- 静的型付け言語
  - 変数の型はコンパイル時に決定される。
    - 一度宣言された変数の型は変更することができない  
    e.g.) C言語、Java、Go言語 

### Go言語の概要とその特性
　Go言語の設計は、簡潔さと効率性に重きを置いてる。開発者が直感的に理解でき、読みやすく保守しやすいコードを書けるよう、シンプルな構文が採用されている。また、Goはプログラム全体のパフォーマンスに大きな影響を与える「並行性」を基本からサポートしていて、Goの「ゴルーチン」や「チャネル」などの並行処理機能は、大規模で高性能なシステムを効率良く開発するための強力なツールとなる。  

　Goは、ソフトウェア開発の生産性を最大化するために設計されている。それはシンプルな構文と、優れた並行処理機能を持つことで知られている。さらにGoは静的型付け言語であるため、型に関するエラーを早期に検出でき、バグを減らすことが可能である。その他にも、Garbage Collection(ガベージコレクション)、パッケージシステム、テストフレームワークなどがある。  

## Go言語の基本
### Goコマンド
　コンパイラ、コードのフォーマッタ、リンター、依存性管理、テストランナーのためのツールが用意されている。

#### go run
　以下の`hello.go`を用意する。

```go:hello.go
package main

import "fmt"

func main() {
	fmt.Println("Hello, world!")
}
```
　ターミナルでファイルを保存したディレクトリに移動し次のコマンドを実行するとターミナルに「Hello world!」と表示される。
```bash
$ go run hello.go
Hello, world!
```

　go runを実行する際には裏側では以下のような処理が行われている。
1. go runでバイナリファイルがビルドされ一時ディレクトリに置かれる
2. そのファイルを実行する
3. プログラムの実行後、そのファイルが削除される


#### go build
　再利用できるように実行形式のバイナリファイルを作成したい場合は、go buildを使う

```bash
$ go build hello.go
```
　これによって`hello`という実行形式ファイルが同じディレクトリ内に生成される。これを実行すると先ほどと同じように「Hello, World!」が表示される。

```bash
$ ./hello
Hello, world!
```

#### go mod
　Go言語では、モジュールとパッケージ管理のために`go mod`コマンドを使用する。Goのモジュールは、特定のディレクトリ内にあるGoパッケージの集合で、一緒にバージョン管理される。  
　まずプロジェクトのディレクトリを作成し移動して、`go mod`コマンドを実行してモジュールを初期化する。

```bash
$ mkdir hello-world
$ cd hello-world
$ go mod init hello-world
```

※ モジュールを公開する場合は「github.com/\<モジュール名\>」のように公開するリポジトリの場所と機能を表す名称を指定する。  
　`go mod init hello-world`を実行すると`go.mod`というファイルが作成される。

```mod:go.mod
module hello-world

go 1.19
```

先ほどのファイル`hello.go`をコピーしてhello-worldディレクトリに入れる。

```bash
$ cp ../hello.go .
```

ファイルを保存したら以下の2つのコマンドを実行する

```bash
$ go mod tidy
$ go build
```

`go.mod`ファイルがあると、ファイルを指定しなくてもそのディレクトリに置かれた`.go`ファイルを解析してコンパイルしてビルドしてくれる。`go.mod`ファイルに`module hello-world`と書かれているので、`hello-world`というコマンドが作成される。  
「`go mod tidy`」は、ソースファイルを解析して必要なサーバパーティのライブラリのダウンロードや不要になったファイルの削除などを行ってくれる。


## 基本型と宣言
### ゼロ値
　Go言語では、明示的に初期値を設定していない変数はゼロ値と呼ばれるデフォルト値が自動的に割り当てられる。各型のゼロ値は以下の通り。
- 数値型(int, floatなど)：0
- bool型：false
- string型：""(空文字)

```go
var i int
var f float64
var b bool
var s string
fmt.Println(i, f, b, s)
```

```bash:実行結果
0 0 false 
```

### リテラル
リテラルとは、ソースコード内で直接表現される固定値のことを指す。  
Go言語のリテラルには数値(2種類)、文字、文字列がある

```go
var i = 123  // 整数リテラル
var f = 3.14 // 浮動小数点リテラル
var s = "Hello, Go"  // 文字列リテラル
var b = true  // ブールリテラル
```

### 整数リテラル
整数リテラルには10進数、16進数、8進数、2進数がある。  
またGo言語では長い数字のリテラルを読みやすくするために、整数リテラルの任意の箇所に「_」を書くことができる。

```go
var i1 = 123  // 10進数
var i2 = 0x7B // 16進数（123）
var i3 = 0173 // 8進数（123）
var i4 = 0b1111011 // 2進数（123）
var i5 = 1_000 // (1000)
```

### 浮動小数点リテラル
浮動小数点リテラルには、小数形式と指数形式がある。

```go
var f1 = 3.14
var f2 = .123 // 0から始まることも可能
var f3 = 1.23e-3 // 1.23 x 10^-3 = 0.00123
```

### runeリテラル
`rune`はGo言語の型で、UTF-8の文字(Unicodeコードポイント)を表現する。

```go
var r1 = 'A'  // 'A'のUnicodeコードポイントは65
var r2 = '\141' // 8ビッド8進数
```

### 文字列リテラル
Go言語には2つの形式の文字列リテラルがある。ダブルクォートとバッククォートである。

```go
var s1 = "Hello, Go"  // ダブルクォート
var s2 = `Hello, 
Go`  // バッククォート。マルチラインの文字列を作成できます。
```

### 論理型bool
真偽値(論理値、ブール値)を値として持つ変数の型は論理型(boolean)になる。

```go
var b1 = true
var b2 = false
```

### 明示的型変換
　Go言語は静的型付け言語であるため、一度変数に型が宣言されると、その後その型を変更することはできない。しかし、時としてある型の値を別の型の値に変換する必要がある。このような場合、Go言語では明示的な型変換（type conversionまたはtype casting）を行う。  
　型変換を明示的に行うことで、意図しない型変換を防ぎ、プログラムの安全性と信頼性を高めることができる。

```go
var x int = 10
var y float64 = 30.2
var z float64 = float64(x) + y
var d int = x + int(y)
fmt.Println(z, d)
```

```bash:実行結果
40.2 40
```

### 変数の宣言
　Go言語における変数の宣言は、変数の型の明示性と初期化に重点を置いた設計が特徴である。これにより、Goプログラムは一貫性を保ち、かつ意図しないエラーの可能性を低減することができる。  
　Go言語における変数の宣言は、基本的に以下の3つの方式が存在する。

1. `var`キーワードを使用する基本的な形式
```go
var x int
var y = 3.14  // 型を省略可能、Goコンパイラが型推論を行う
```

2. ショートアサインメント(`:=`)を使用する形式(関数内でのみ使用可能)
```go
x := 42  // varと型の宣言を省略可能
```

3. 複数の変数を一度に宣言する形式
```go
var a, b, c int  // 同じ型の変数を複数宣言
var d, e = 5, "five"  // 型が異なる複数の変数を宣言と初期化
```

### 定数
Go言語では、不変の値を表現するために定数（Constants）が提供されている。定数はconstキーワードを使用して定義され、一度定義されるとその値は変更できない。定数は、実際にはリテラル値に「名前」を付けるためのものと考えることができる。

```go
const Pi = 3.14
```

重要な点として、Goの定数はコンパイル時に決定できる値を保持するためのものである。定数は数値、boolean、文字列、runeのみで使うことができる。また、Goでは型を持つ定数と型を持たない定数の両方が存在する。型を持たない定数は、コンパイル時に必要な精度を持つことができ、さまざまな文脈で利用できる。

```go
const NoTypeConst = 42  // 型を持たない定数
var i int = NoTypeConst  // int型の変数に型を持たない定数を代入可能
var f float64 = NoTypeConst  // float64型の変数にも型を持たない定数を代入可能
```

## 合成型
### 配列
配列は固定長の要素の集合で、全ての要素は同じ型でなければならない。配列を定義するには以下のようにする。

```go
var arr [5]int // 長さ5のint型配列
arr[0] = 1     // インデックス0の要素に1を代入
arr[1] = 2     // インデックス1の要素に2を代入
```

値を指定する場合は、次のように「配列リテラル」を用いる。

```go
var arr = [3]int{10, 20, 30}
```

Go言語には1次元の配列しかないが、次のようにすることで多次元配列のように使うことができる。  
これによるarrは長さ2の配列になるが、その型は長さ3の整数配列ということになる
```go
var arr [2][3]int
fmt.Println(arr)
```

```bash:実行結果
[[0 0 0] [0 0 0]]
```

Goでは配列の大きさを配列の「型」の一部としてみなしている。つまり[3]intと宣言した配列と[4]intと宣言した配列では型が異なることになる。
※ 配列はGoでよく使われる「スライス」の「後方支援」のために存在している。

### スライス
スライスは可変長の要素の集合で、配列と同様に全ての要素は同じ型でなければならない。スライスは配列よりも柔軟であり、Goのコードでは配列よりもスライスがよく使われる。

```go
var slice = []int{10, 20, 30}
```

```go
slice := make([]int, 5) // 長さ5のint型スライス
slice[0] = 1            // インデックス0の要素に1を代入
slice = append(slice, 6) // スライスの末尾に6を追加
fmt.Println(slice)
fmt.Println(len(slice))
```

```bash:実行結果
[1 0 0 0 0 6]
6
```

### マップ
Go言語におけるマップ(map)は、キーと値をペアで格納するデータ構造を提供する。  
他の言語では連想配列、ハッシュマップ、ディクショナリーなどとも呼ばれる。キーに対応する値を高速に取得することができ、データの検索や格納に使える。

**マップの宣言方法**

```go
map[<キーの値>]<値の型>

var ages map[string]int
```
上記の場合、agesはstringをキーにもち、intを値として持つことになる。マップのゼロ値はnilで、agesの初期値もnilになる。len(ages)の値は0になる。上記のagesから読み込みを行うと、常に値の型のゼロ値が返される。しかし、nilマップに対して書き込みを行うとパニックになる。  
※ したがって、マップに要素を加えて利用する場合は、上のような宣言は行わない

`:=`を使うと**マップリテラル**を使った宣言ができる。

```go
ages := map[string]int{}  // string→intのマップを要素なしで初期化
```

この空のマップリテラルで初期化すると、そのマップに対して読み書きの両方が可能になる。

```go
ages["Alice"] = 30
ages["Bob"] = 31
fmt.Println(ages)
```

```bash:実行結果
map[Alice:30 Bob:31]
```

```go
age := ages["Alice"]
fmt.Println(age) 
```

```bash:実行結果
30
```


