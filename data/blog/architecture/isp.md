---
title: SOLID原則を理解したい~インターフェース分離の原則編~
date: '2023-07-09'
tags: ['architecture', 'solid']
draft: false
summary: SOLID原則についてそれぞれ理解を深めたい記事
---

## 目次

<TOCInline toc={props.toc} exclude="目次" toHeading={3} />

## ISP: インターフェースの原則
### インターフェース分離の原則とは

> クライアントは、それが使用しないメソッドに依存すべきではない

あるクラスが広範囲の機能を持つ大きなインターフェースに依存している場合、それはそのインターフェースのすべてのメソッドに依存してしまう。しかし、実際にはそのクラスが必要とするのはそのうちの一部の機能だけかもしれない。このような場合、クラスは不必要なメソッドにも依存してしまい、余計な結合が生じる。

[![Image](https://i.gyazo.com/71c286eec1dbb0742a766d7b315f8888.png)](https://gyazo.com/71c286eec1dbb0742a766d7b315f8888)

上の図では、複数のユーザーが同じOPSクラスを使っている。ここでは、User1がop1を使い、User2がop2を使い、User3がop3を使っているものとする。  
OPSがJavaのような言語で書かれたクラスだとする。User1のソースコードは、実際には使っていないop2とop3にも意図せず依存している。ここでいう「依存」とは、op2のコードを変更したときにUser1の再コンパイルと再デプロイが必要になるという意味である。  
この問題を解決するには、各操作をインターフェースに分離すればいい。

[![Image](https://i.gyazo.com/c9707858b9faf29ecb9c01b331a869e2.png)](https://gyazo.com/c9707858b9faf29ecb9c01b331a869e2)

User1のそーすコードはU1Opsとop1には依存しているが、OPSには依存していない。つまり、OPSに変更があったとしても、もしそれがUser1に関係のない部分であれば、User1の再コンパイルと再デプロイは不要になる。
