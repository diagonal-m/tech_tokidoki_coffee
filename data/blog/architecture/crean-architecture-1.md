---
title: Clean Architecture備忘録vol.1
date: '2023-07-03'
tags: ['architebure', 'clean architecure']
draft: false
summary: 'Clean Architecture~達人に学ぶソフトウェアの構造と設計~を読んでの備忘録vol.1'
---

## 目次

<TOCInline toc={props.toc} exclude="目次" toHeading={3} />

## 設計とアーキテクチャ
### 設計とアーキテクチャの違いは？
一般的にアーキテクチャと設計は以下のような使い分けがされている  
**アーキテクチャ**
> 下位レベルの詳細とは切り離された文脈で使用される

**設計**
> 下位レベルの構造や意思決定を表している 

→ **両者に違いはない！**
> 下位レベルの詳細と上位レベルの構造は全体の設計の一部となる。それらが連続した構造を作り、システムの形状を定義する。  
...  
最上位レベルから最下位レベルまで、決定の連続なのである。

### 優れたソフトウェア設計の目的とは何か？
> ソフトウェアアーキテクチャの目的は、求められるシステムを構築・保守するために必要な人材を最小限に抑えることである。

## 設計の原則
### SRP：単一責任の原則

> モジュールはたったひとつのアクター(変更を望む人たち)に対して責務を負うべきである  
(アクターの異なるコードは分割すべき)

モジュール：端的に言えば、ソースファイル。いくつかの関数やデータをまとめた凝集性のあるもの。

### OCP：オープン・クローズドの原則

> ソフトウェアの振る舞いは、既存の成果物を変更せず拡張できるようにするべき 

> オープン・クローズドの原則を達成するには、システムをコンポーネントに分割して、コンポーネントの依存関係を階層構造にして、上位レベルのコンポーネントが下位レベルのコンポーネントの変更の影響を受けないようにする。

### LSP: リスコフの置換原則

> S型のオブジェクトo1の各々に、対応するT型のオブジェクトo2が1つ存在し、Tを使って定義されたプログラムPに対してo2の代わりにo1を使ってもPの振る舞いが変わらない場合、SはTの派生型であると言える。

↓

**「派生クラスはその基本クラスと置換可能でなければならない。」**
> もしクラスBがクラスAの派生クラスであれば、我々はクラスAのオブジェクトをクラスBのオブジェクトで置換しても、プログラムは正常に動作し続けるべきである 


### ISP: インターフェイス分離の法則

> 特定のクライアントに役立たない、または必要としないメソッドへの依存を避けるべきである

一つの大きなインターフェースに多くのメソッドが含まれていると、それを実装するクラスは、実際には使用しないメソッドにも依存することになる。この結果、不必要な依存関係が生じ、それによって他のクラスにまで影響を及ぼす可能性がある。さらに、大きなインターフェースを利用すると、クラスの再利用性も低下する。

そのため、ISPはこのような問題を防ぐために、「より小さな、特定の目的に特化したインターフェースを使用するように」と提案する。
