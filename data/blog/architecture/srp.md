---
title: SOLID原則を理解したい~単一責任の原則編~
date: '2023-07-03'
tags: ['architecture', 'solid']
draft: true
summary: 'SOLID原則についてそれぞれ理解を深めたい記事'
---

## 目次

<TOCInline toc={props.toc} exclude="目次" toHeading={3} />

## SRP: 単一責任の原則

### 単一責任の原則とは何か？

> モジュールを変更する理由はたったひとつだけであるべきである。

ソフトウェアシステムに手を加えるのは、ユーザーやステークホルダーを満足させるためである。この「ユーザーやステークホルダー」こそが、単一責任の原則(SRP)が指す「変更する理由」である。  
　複数のユーザーやステークホルダーのような変更を望む人たちをひとまとめにした**アクター**とすると、単一責任の原則は以下のように言い換えることができる。

> モジュールはたったひとつのアクターに対して責務を負うべきである。

#### よくある誤解

> どのモジュールもたったひとつのことだけを行うべき

上記のようなひとつの関数はたったひとつのことだけを行うべきという原則も存在するが、これは巨大な関数にリファクタリングを施して、小さな関数に切り分けるときに使う原則のことである。これを用いるのは最下位のレベルであり、SOLID 原則の単一責任の原則とは別のものになる。

### SRP 違反の例

`Book`クラスは図書管理システムの一部で、`calculateFine()`と`getBorrowerInfo()`の 2 つのメソッドを含む。

```bash
+---------------------------------+
|             Book                |
+---------------------------------+
| -BookData: String               |
|---------------------------------|
| +calculateFine(): double        |
| +getBorrowerInfo(): String      |
+---------------------------------+
```

これらのメソッドはそれぞれ異なるアクター（ユーザー）に対する責任を担っているため、単一責任の原則（SRP）に反している。

- `calculateFine()`は会計部門が遅延罰金を算出する目的で使用する。
- `getBorrowerInfo()`はカスタマーサービス部門が借り手の情報を取得するために使用する。

`Book`クラスがこれらの異なるニーズを一度に満たすため、一方の変更が他方に影響を及ぼすリスクがある。

例えば、両メソッドで貸出期間を計算する部分があるとする。この重複したコードを避けるために、開発者は共通部分を`borrowingPeriod()`メソッドに抽出する。

```bash
+----------------------+  +----------------------+
|  calculateFine()     |  |  getBorrowerInfo()  |
+----------------------+  +----------------------+
           |                          |
           +-------+          +-------+
                   ↓          ↓
            +-----------------------+
            |    borrowingPeriod()  |
            +-----------------------+
```

しかし、会計部門は罰金の計算方法で貸出期間の算出法を変更したいと要求してきたとしよう。カスタマーサービス部門ではこの変更は不要なので、何も行わない。

その結果、開発者が`borrowingPeriod()`を更新し、会計部門の要求を満たすと、カスタマーサービス部門が知らないなままで、`getBorrowerInfo()`が返す情報が誤っている可能性がある。

この問題の根源は、**一つのクラスが複数のアクターに対応していること**にある。単一責任の原則（SRP）は、異なるアクターのコードを分割するべきという原則である。

### 解決策

このような問題を解消するためには、関数やデータを別のクラスに移動させる方法が考えられる。たとえば、次のような 3 つの新しいクラスを作成する。

```bash
+------------------------+
|       BookData         |
+------------------------+
| -title: String         |
| -author: String        |
| -borrower: String      |
| -borrowingDate: Date   |
+------------------------+
```

この`BookData`クラスは`Book`クラスからデータを分離したもので、特定のデータを保持するだけで、メソッドは含まれていない。

次に、`calculateFine()`メソッドを担当する`Accounting`クラスを作成する。

```
+----------------------------------------+
|         Accounting                     |
+----------------------------------------+
| +calculateFine(book: BookData): double |
+----------------------------------------+
```

`getBorrowerInfo()`メソッドを担当する`CustomerService`クラスも作成する。

```
+------------------------------------------+
|     CustomerService                      |
+------------------------------------------+
| +getBorrowerInfo(book: BookData): String |
+------------------------------------------+
```

これらのクラスは、それぞれ特定の機能を提供し、他のクラスの存在や動作については知らない。

しかしこの設計では、クライアントコードがこれら 3 つのクラスすべてを知っている必要がある。これを簡単にするためには Facade パターンを用いる。Facade パターンはクライアントから見て複雑なサブシステムを単純化し、一つのインターフェースを提供するデザインパターンである。

Facade パターンを適用した`Library`クラスを追加する

```
+--------------------------------------------------------------+
|                Library                                       |
+--------------------------------------------------------------+
| -bookData: BookData                                          |
| -accounting: Accounting                                      |
| -customerService: CustomerService                            |
|--------------------------------------------------------------|
| +borrowBook(title: String, author: String, borrower: String) |
| +returnBook(title: String, author: String, borrower: String) |
| +calculateFine(title: String, author: String): double        |
| +getBorrowerInfo(title: String, author: String): String      |
+--------------------------------------------------------------+
```

`Library`クラスは、`BookData`、`Accounting`、そして`CustomerService`という 3 つのクラスを一つにまとめているクラスで、これを Facade（ファサード）と呼ぶ。ファサードとは、建物の正面や外見を意味する言葉で、ここでは「見た目を簡素にする」機能を果たしてる。

この`Library`クラスが提供する各メソッドは、それぞれ内部で`BookData`、`Accounting`、`CustomerService`クラスのメソッドを呼び出している。しかし、これらの詳細な作業は`Library`クラスの外からは見えない。つまり、`Library`クラスはそれらのクラスの複雑さを隠蔽し、クライアント（`Library`クラスを使用するコード）から見れば、一つのシンプルなクラスとして操作できる。

コードを書く際には、`BookData`、`Accounting`、`CustomerService`といった各クラスを個別に扱うのではなく、`Library`クラスのメソッドを通じて必要な機能を利用する。これにより、コードの見通しが良くなり、複雑性も抑えることができる。

例えば、本を借りる場合、`Library`クラスの`borrowBook`メソッドを呼び出すだけで、適切な`BookData`が作成され、必要な操作が全て行われる。同様に、罰金を計算する場合や借りているユーザーの情報を取得する場合も、`Library`クラスの対応するメソッドを呼び出すだけで、その裏で複数のクラスが協力して動作してくれる。

### まとめ

1. **定義**: 「単一責任の原則」はソフトウェア設計の原則の一つで、ソフトウェアの各部分（クラスや関数など）は一つの変更の理由だけを持つべきだというもの。

2. **目的**: SRP は、コードの複雑性を低減し、可読性、保守性、再利用性を向上させるためのも。単一の責任を持つことで、それぞれの部分が自分の責任範囲内の変更にのみ反応し、他の部分には影響を及ぼさないようにすることが目的。

3. **違反の問題点**: 一つのクラスや関数が複数の責任を持つ場合、それらの責任が互いに結合され、一つの責任の変更が他の責任に影響を及ぼす可能性がある。これはコードの管理を難しくし、バグを生み出す可能性がある。

4. **解決策**: 関連性のある操作を異なるクラスや関数に分割することで、それぞれの部分が一つの責任だけを持つようにする。また、Facade パターンのような設計パターンを使用して、複数のクラスの複雑さを一つのインターフェースに隠蔽することで、クライアントから見た複雑さを軽減する。
