---
title: SOLID原則を理解したい~オープン・クローズドの原則編~
date: '2023-07-08'
tags: ['architecture', 'solid']
draft: false
summary: 'SOLID原則についてそれぞれ理解を深めたい記事'
---

## 目次

<TOCInline toc={props.toc} exclude="目次" toHeading={3} />

## OCP: オープン・クローズドの原則

### オープン・クローズドの原則とは

> ソフトウェアの構成要素は拡張に対して開いていて、修正に対しては閉じていなければならない

これは言い換えると、既存のソフトウェアの動作を変更せずに新たな機能を追加できるようにするべき、ということである。

### 財務情報表示システムの例

財務情報を Web ページに表示するシステムを考える。ページ上のデータはスクロールできて、負の数字は赤く表示される。  
「画面に出ている内容と同じものを、白黒のプリンターで印刷したい」という要望が出たとする。印刷するとしたら、負の数値は括弧で囲むなど適切なページ処理が必要になる。  
以下のフロー図は財務データを分析して会計報告データを生成し、これを二種類の出力処理で適切にフォーマットすることを表している。
[![image](https://i.gyazo.com/75d3e583935685f72d1ef9d6696b076f.png)](https://gyazo.com/75d3e583935685f72d1ef9d6696b076f)

ここで重要なのは、レポートの作成は 2 つの異なる責務を伴うことである。出力するデータの計算と、ウェブ(あるいは印刷)向けの表示形式の作成である。  
この 2 つを分離するには、ソースコードの依存関係を適切に調整し、一方に影響を与えることなく変更できるようにする必要がある。  
これを実現するには、処理をクラスに分割して、それぞれのクラスをコンポーネントにまとめる。左上のコンポーネントが`Controller`, 右上が`Interactor`, そのしたが`Database`である。左下には`Presenter`と`View`を表すコンポーネントがある。

[![image](https://i.gyazo.com/c244e6d7701eedb94074cdbd414fc78c.png)](https://gyazo.com/c244e6d7701eedb94074cdbd414fc78c)

コンポーネントの関係はすべて単方向になっている。矢印の向かっている先が、自分自身を変更したときに影響を及ぼしたくないコンポーネントである。

コンポーネント A がコンポーネント B の変更から保護されるべきならば、コンポーネント B からコンポーネント A に依存すべきである。  
ここでは**Presenter**を変更した時に、**Controller**を変更する必要をなくしたい。**Views**を変更した時に、**Presenter**を変更する必要をなくしたい。他のすべてを変更した時に、**Interactor**を変更する必要をなくしたい。  
「レベル」の概念にもとづいた保護の階層ができていることに注目する。**Interactor**は最上位レベルの概念なので、これが最も保護される。**View**は最下位レベルの概念なので、保護レベルは最も低くなる。**Presenter**は**View**よりも上位にあるが、**Controller**や**Interactor**よりも下位レベルにある概念である。  
これが、アーキテクチャレベルにおけるオープン・クローズドの原則(OCP)だ。アーキテクトは、いつどのような理由でどのように変更するかを考えて機能を分割する。そして、分割した機能をコンポーネントの階層構造にまとめる。上位レベルにあるコンポーネントは、下位レベルのコンポーネントが変更されたとしても、変更する必要はない。

## まとめ

オープン・クローズドの原則の目的は、変更の影響を受けずにシステムを拡張しやすくすることにある。目的を達成するために、システムをコンポーネントに分割して、コンポーネントの依存関係を階層構造にする。そして、上位レベルのコンポーネントが下位レベルのコンポーネントの変更の影響を受けないようにする。
